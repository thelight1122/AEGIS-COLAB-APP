[{"filePath":"E:\\AEGIS-COLAB-APP\\eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\playwright.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\scripts\\runPlaywright.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\scripts\\testRunId.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\__tests__\\auth-rls-board-happy-path.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\__tests__\\board-stabilization.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\__tests__\\realtime-presence.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\components\\chamber\\AttachDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\components\\chamber\\ChamberLayout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\components\\chamber\\CreateNodeModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\components\\chamber\\IDSStream.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\components\\chamber\\PeerPresence.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\components\\chamber\\TelemetryPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\components\\chamber\\WhiteboardArea.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\components\\chamber\\nodes\\BaseNode.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\components\\chamber\\nodes\\ProposalNode.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\components\\chamber\\nodes\\StructureNodes.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\components\\chamber\\nodes\\TensionNode.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\components\\chamber\\nodes\\nodeTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\components\\layout\\AppShell.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\components\\layout\\Header.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\components\\layout\\Sidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\components\\ui\\AuthPanel.test.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":83,"column":88,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":83,"endColumn":91,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3119,3122],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3119,3122],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/** @vitest-environment jsdom */\r\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\r\nimport { render, screen, fireEvent, act } from '@testing-library/react';\r\nimport { AuthPanel } from './AuthPanel';\r\nimport { supabase } from '../../core/supabase/client';\r\nimport { useAuthSession } from '../../core/auth/useAuthSession';\r\nimport type { Session, User, AuthOtpResponse } from '@supabase/supabase-js';\r\nimport '@testing-library/jest-dom';\r\n\r\nvi.mock('../../core/supabase/client', () => ({\r\n    supabase: {\r\n        auth: {\r\n            signInWithOtp: vi.fn(),\r\n            signOut: vi.fn()\r\n        }\r\n    }\r\n}));\r\n\r\nvi.mock('../../core/auth/useAuthSession', () => ({\r\n    useAuthSession: vi.fn()\r\n}));\r\n\r\ndescribe('AuthPanel', () => {\r\n    beforeEach(() => {\r\n        vi.clearAllMocks();\r\n        localStorage.clear();\r\n        vi.useFakeTimers();\r\n        vi.setSystemTime(new Date('2026-01-01T12:00:00Z'));\r\n    });\r\n\r\n    afterEach(() => {\r\n        vi.useRealTimers();\r\n    });\r\n\r\n    it('should call signInWithOtp on form submission and enter cooldown', async () => {\r\n        vi.mocked(useAuthSession).mockReturnValue({ session: null, user: null, loading: false });\r\n        // Use a promise that resolves immediately\r\n        const signInPromise = Promise.resolve({\r\n            data: { user: null, session: null },\r\n            error: null\r\n        } as AuthOtpResponse);\r\n        vi.mocked(supabase.auth.signInWithOtp).mockReturnValue(signInPromise);\r\n\r\n        render(<AuthPanel />);\r\n\r\n        const emailInput = screen.getByPlaceholderText(/agent@aegis-facility.org/i);\r\n        const sendButton = screen.getByRole('button', { name: /send magic link/i });\r\n\r\n        fireEvent.change(emailInput, { target: { value: 'test@example.com' } });\r\n\r\n        // Wrap everything in act and await the promise\r\n        await act(async () => {\r\n            fireEvent.click(sendButton);\r\n            await signInPromise;\r\n        });\r\n\r\n        // Advance timers to trigger the first setCooldown/interval\r\n        act(() => {\r\n            vi.advanceTimersByTime(0);\r\n        });\r\n\r\n        expect(screen.getByText(/magic link sent/i)).toBeDefined();\r\n        expect(screen.getByText(/retry in 60s/i)).toBeDefined();\r\n        expect(screen.getByRole('button', { name: /retry in 60s/i })).toBeDisabled();\r\n    });\r\n\r\n    it('should persist cooldown across renders/mounts', async () => {\r\n        vi.mocked(useAuthSession).mockReturnValue({ session: null, user: null, loading: false });\r\n\r\n        const now = Date.now();\r\n        const future = now + 45000;\r\n        localStorage.setItem('aegis_auth_cooldown', future.toString());\r\n\r\n        render(<AuthPanel />);\r\n\r\n        expect(screen.getByText(/retry in 45s/i)).toBeDefined();\r\n    });\r\n\r\n    it('should handle rate limit error gracefully', async () => {\r\n        vi.mocked(useAuthSession).mockReturnValue({ session: null, user: null, loading: false });\r\n        const rateLimitPromise = Promise.resolve({\r\n            data: { user: null, session: null },\r\n            error: { message: 'Email rate limit exceeded', status: 429 } as unknown as any\r\n        } as AuthOtpResponse);\r\n        vi.mocked(supabase.auth.signInWithOtp).mockReturnValue(rateLimitPromise);\r\n\r\n        render(<AuthPanel />);\r\n\r\n        const emailInput = screen.getByPlaceholderText(/agent@aegis-facility.org/i);\r\n        const sendButton = screen.getByRole('button', { name: /send magic link/i });\r\n\r\n        fireEvent.change(emailInput, { target: { value: 'spam@example.com' } });\r\n\r\n        await act(async () => {\r\n            fireEvent.click(sendButton);\r\n            await rateLimitPromise;\r\n        });\r\n\r\n        expect(screen.getByText(/email sending is temporarily limited/i)).toBeDefined();\r\n        expect(screen.getByRole('button', { name: /retry in 60s/i })).toBeDisabled();\r\n    });\r\n\r\n    it('should resume countdown and enable button after cooldown', async () => {\r\n        vi.mocked(useAuthSession).mockReturnValue({ session: null, user: null, loading: false });\r\n        const successPromise = Promise.resolve({\r\n            data: { user: null, session: null },\r\n            error: null\r\n        } as AuthOtpResponse);\r\n        vi.mocked(supabase.auth.signInWithOtp).mockReturnValue(successPromise);\r\n\r\n        render(<AuthPanel />);\r\n\r\n        fireEvent.change(screen.getByPlaceholderText(/agent@aegis-facility.org/i), { target: { value: 'timer@example.com' } });\r\n\r\n        await act(async () => {\r\n            fireEvent.click(screen.getByRole('button', { name: /send magic link/i }));\r\n            await successPromise;\r\n        });\r\n\r\n        expect(screen.getByText(/retry in 60s/i)).toBeDefined();\r\n\r\n        // Advance timers by 60s + a small buffer\r\n        act(() => {\r\n            vi.advanceTimersByTime(61000);\r\n        });\r\n\r\n        expect(screen.queryByText(/retry in/i)).toBeNull();\r\n        expect(screen.getByRole('button', { name: /send magic link/i })).not.toBeDisabled();\r\n    });\r\n\r\n    it('should call signOut when clicking sign out button', async () => {\r\n        const mockUser = { email: 'active@example.com' } as User;\r\n        const mockSession = { user: mockUser } as Session;\r\n        vi.mocked(useAuthSession).mockReturnValue({\r\n            session: mockSession,\r\n            user: mockUser,\r\n            loading: false\r\n        });\r\n\r\n        render(<AuthPanel />);\r\n\r\n        const signOutButton = screen.getByRole('button', { name: /sign out/i });\r\n        fireEvent.click(signOutButton);\r\n\r\n        expect(supabase.auth.signOut).toHaveBeenCalled();\r\n    });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\components\\ui\\AuthPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\components\\ui\\AuthStatus.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\components\\ui\\ConfigStatus.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\components\\ui\\avatar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\components\\ui\\button.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\components\\ui\\card.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\components\\ui\\dialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\components\\ui\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\components\\ui\\input.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\components\\ui\\scroll-area.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\components\\ui\\textarea.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\contexts\\IDSContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":2,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":98,"column":17,"nodeType":"Identifier","messageId":"namedExport","endLine":98,"endColumn":23}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createContext, useContext, useState, useCallback, type ReactNode } from 'react';\r\nimport { type IDSCard, type Attachment, MOCK_IDS_FEED } from '../types';\r\nimport { isE2E } from '../lib/e2e';\r\n\r\ninterface NodeOption {\r\n    id: string;\r\n    label: string;\r\n    type: string;\r\n}\r\n\r\ninterface IDSContextType {\r\n    idsCards: IDSCard[];\r\n    canvasNodes: NodeOption[];\r\n    focusNodeId: string | null;\r\n    addCard: (type: IDSCard['type'], content: string) => void;\r\n    clearStream: () => void;\r\n    attachNode: (cardId: string, nodeId: string) => void;\r\n    removeAttachment: (cardId: string, attachmentId: string) => void;\r\n    setNodes: (nodes: NodeOption[]) => void;\r\n    setFocusNode: (nodeId: string | null) => void;\r\n}\r\n\r\nconst IDSContext = createContext<IDSContextType | undefined>(undefined);\r\n\r\nexport function IDSProvider({ children }: { children: ReactNode }) {\r\n    const [idsCards, setIdsCards] = useState<IDSCard[]>(isE2E() ? [] : MOCK_IDS_FEED);\r\n    const [canvasNodes, setCanvasNodes] = useState<NodeOption[]>([]);\r\n    const [focusNodeId, setFocusNodeId] = useState<string | null>(null);\r\n\r\n    const addCard = useCallback((type: IDSCard['type'], content: string) => {\r\n        const newCard: IDSCard = {\r\n            id: `c-${Date.now()}`,\r\n            type,\r\n            content,\r\n            authorId: 'p1', // Current User\r\n            timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\r\n            attachments: []\r\n        };\r\n        setIdsCards(prev => [newCard, ...prev]);\r\n    }, []);\r\n\r\n    const clearStream = useCallback(() => {\r\n        setIdsCards([]);\r\n    }, []);\r\n\r\n    const attachNode = useCallback((cardId: string, nodeId: string) => {\r\n        setIdsCards(prev => prev.map(card => {\r\n            if (card.id !== cardId) return card;\r\n            const node = canvasNodes.find(n => n.id === nodeId);\r\n            if (!node) return card;\r\n            const existing = card.attachments || [];\r\n            if (existing.some(a => a.targetId === nodeId)) return card;\r\n            const newAttachment: Attachment = {\r\n                id: `att-${Date.now()}`,\r\n                type: 'node',\r\n                label: node.label,\r\n                targetId: nodeId,\r\n            };\r\n            return { ...card, attachments: [...existing, newAttachment] };\r\n        }));\r\n    }, [canvasNodes]);\r\n\r\n    const removeAttachment = useCallback((cardId: string, attachmentId: string) => {\r\n        setIdsCards(prev => prev.map(card => {\r\n            if (card.id !== cardId) return card;\r\n            return {\r\n                ...card,\r\n                attachments: (card.attachments || []).filter(a => a.id !== attachmentId),\r\n            };\r\n        }));\r\n    }, []);\r\n\r\n    const setNodes = useCallback((nodes: NodeOption[]) => {\r\n        setCanvasNodes(nodes);\r\n    }, []);\r\n\r\n    const setFocusNode = useCallback((nodeId: string | null) => {\r\n        setFocusNodeId(nodeId);\r\n    }, []);\r\n\r\n    return (\r\n        <IDSContext.Provider value={{\r\n            idsCards,\r\n            canvasNodes,\r\n            focusNodeId,\r\n            addCard,\r\n            clearStream,\r\n            attachNode,\r\n            removeAttachment,\r\n            setNodes,\r\n            setFocusNode\r\n        }}>\r\n            {children}\r\n        </IDSContext.Provider>\r\n    );\r\n}\r\n\r\nexport function useIDS() {\r\n    const context = useContext(IDSContext);\r\n    if (!context) {\r\n        throw new Error('useIDS must be used within an IDSProvider');\r\n    }\r\n    return context;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\core\\aiSim\\rolePack.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\core\\auth\\useAuthSession.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\core\\auth\\useAuthSession.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\core\\e2e\\e2eHarness.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\core\\governance\\inclusionState.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\core\\governance\\inclusionState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\core\\governance\\shadowSentinel.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\core\\governance\\systemLenses.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\core\\governance\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\core\\mcp\\governedOperation.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ToolProposal' is defined but never used.","line":7,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":17,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"ToolProposal"},"fix":{"range":[136,155],"text":""},"desc":"Remove unused variable \"ToolProposal\"."}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":46,"column":9,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":46,"endColumn":58,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[1246,1295],"text":"// @ts-expect-error - purposefully passing invalid type"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @vitest-environment jsdom\r\n */\r\nimport { describe, it, expect, beforeEach } from \"vitest\";\r\nimport type {\r\n    GovernedOperation,\r\n    ToolProposal\r\n} from \"./governedOperation\";\r\nimport {\r\n    OperationStatus,\r\n    ToolMode,\r\n    assertGovernedOperation,\r\n    enforceReadOnly\r\n} from \"./governedOperation\";\r\nimport {\r\n    appendOp,\r\n    loadOps,\r\n    deriveCurrentOps,\r\n    updateOpStatus\r\n} from \"./opLedgerStore\";\r\n\r\ndescribe(\"GovernedOperation Governance\", () => {\r\n    const validOp: GovernedOperation = {\r\n        id: \"OP-123\",\r\n        artifactId: \"A-1\",\r\n        createdAt: Date.now(),\r\n        status: OperationStatus.Proposed,\r\n        mode: ToolMode.ReadOnly,\r\n        proposal: {\r\n            toolId: \"t1\",\r\n            toolName: \"Reader\",\r\n            intent: \"Read some data\",\r\n            scope: [\"src/\"],\r\n            constraints: [\"read-only\"],\r\n            rationale: \"Need context\"\r\n        },\r\n        lineage: { sessionId: \"s1\", peerId: \"p1\" }\r\n    };\r\n\r\n    it(\"should validate a correct operation\", () => {\r\n        expect(() => assertGovernedOperation(validOp)).not.toThrow();\r\n    });\r\n\r\n    it(\"should fail validation for missing fields\", () => {\r\n        const invalid = { ...validOp, id: undefined };\r\n        // @ts-ignore - purposefully passing invalid type\r\n        expect(() => assertGovernedOperation(invalid)).toThrow();\r\n    });\r\n\r\n    it(\"should fail validation for invalid IDs\", () => {\r\n        const invalid = { ...validOp, id: \"BAD-ID\" };\r\n        expect(() => assertGovernedOperation(invalid)).toThrow();\r\n    });\r\n\r\n    it(\"should enforce read-only policy\", () => {\r\n        expect(() => enforceReadOnly(validOp)).not.toThrow();\r\n        const writeOp = { ...validOp, mode: ToolMode.Write as ToolMode };\r\n        expect(() => enforceReadOnly(writeOp)).toThrow(/Phase 1 Error/);\r\n    });\r\n});\r\n\r\ndescribe(\"OpLedgerStore (Append-Only)\", () => {\r\n    beforeEach(() => {\r\n        localStorage.clear();\r\n    });\r\n\r\n    it(\"should handle append-only updates via revision chaining\", () => {\r\n        const op: GovernedOperation = {\r\n            id: \"OP-1\",\r\n            artifactId: \"A-1\",\r\n            createdAt: Date.now(),\r\n            status: OperationStatus.Proposed,\r\n            mode: ToolMode.ReadOnly,\r\n            proposal: {\r\n                toolId: \"t1\", toolName: \"T\", intent: \"I\", scope: [], constraints: [], rationale: \"R\"\r\n            },\r\n            lineage: {}\r\n        };\r\n\r\n        appendOp(op);\r\n        expect(loadOps()).toHaveLength(1);\r\n\r\n        updateOpStatus(\"OP-1\", { status: OperationStatus.Requested });\r\n\r\n        const ledger = loadOps();\r\n        expect(ledger).toHaveLength(2);\r\n        expect(ledger[1].previousId).toBe(\"OP-1\");\r\n        expect(ledger[1].status).toBe(OperationStatus.Requested);\r\n    });\r\n\r\n    it(\"should derive the current state from lineage\", () => {\r\n        const op1: GovernedOperation = {\r\n            id: \"OP-1\",\r\n            artifactId: \"A-1\",\r\n            createdAt: 1000,\r\n            status: OperationStatus.Proposed,\r\n            mode: ToolMode.ReadOnly,\r\n            proposal: { toolId: \"t1\", toolName: \"T\", intent: \"P1\", scope: [], constraints: [], rationale: \"\" },\r\n            lineage: {}\r\n        };\r\n        const op2: GovernedOperation = {\r\n            id: \"OP-2\",\r\n            artifactId: \"A-1\",\r\n            createdAt: 1001,\r\n            status: OperationStatus.Proposed,\r\n            mode: ToolMode.ReadOnly,\r\n            proposal: { toolId: \"t2\", toolName: \"T\", intent: \"P2\", scope: [], constraints: [], rationale: \"\" },\r\n            lineage: {}\r\n        };\r\n\r\n        appendOp(op1);\r\n        appendOp(op2);\r\n        updateOpStatus(\"OP-1\", { status: OperationStatus.Requested });\r\n\r\n        const ledger = loadOps();\r\n        const current = deriveCurrentOps(ledger);\r\n        expect(current).toHaveLength(2);\r\n\r\n        // Find the one that corresponds to lineage of OP-1\r\n        const derivedOp1 = current.find(o => {\r\n            const originalId = o.previousId || o.id;\r\n            return originalId === \"OP-1\";\r\n        });\r\n        expect(derivedOp1?.status).toBe(OperationStatus.Requested);\r\n    });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\core\\mcp\\governedOperation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\core\\mcp\\governedToolConduit.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\core\\mcp\\governedToolConduit.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\core\\mcp\\opLedgerStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\core\\mcp\\pathPolicy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\core\\mcp\\useGovernedOperations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\core\\sessions\\sessionStore.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Session' is defined but never used.","line":9,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":22,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"Session"},"fix":{"range":[202,243],"text":""},"desc":"Remove unused import declaration."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, beforeEach, vi } from 'vitest';\r\nimport {\r\n    createSession,\r\n    startSession,\r\n    closeSession,\r\n    canStartSession,\r\n    applyAbandonment\r\n} from './sessionStore';\r\nimport type { Session } from './types';\r\n\r\ndescribe('sessionStore Logic', () => {\r\n    const artifactId = 'A-1';\r\n\r\n    // Mock localStorage\r\n    const localStorageMock = (() => {\r\n        let store: Record<string, string> = {};\r\n        return {\r\n            getItem: (key: string) => store[key] || null,\r\n            setItem: (key: string, value: string) => { store[key] = value.toString(); },\r\n            clear: () => { store = {}; },\r\n            removeItem: (key: string) => { delete store[key]; }\r\n        };\r\n    })();\r\n\r\n    beforeEach(() => {\r\n        Object.defineProperty(global, 'localStorage', { value: localStorageMock, writable: true });\r\n        Object.defineProperty(global, 'crypto', {\r\n            value: { randomUUID: () => `test-uuid-${Math.random()}` },\r\n            writable: true\r\n        });\r\n        localStorage.clear();\r\n        vi.useFakeTimers();\r\n    });\r\n\r\n    it('should allow creating a session in Draft status', () => {\r\n        const { sessions, session } = createSession([], artifactId);\r\n        expect(sessions).toHaveLength(1);\r\n        expect(session.status).toBe('Draft');\r\n        expect(session.artifactId).toBe(artifactId);\r\n    });\r\n\r\n    it('should allow starting a session when none are active', () => {\r\n        const { sessions: s1, session: draft } = createSession([], artifactId);\r\n        const { sessions: s2, session: active } = startSession(s1, draft.id);\r\n        expect(active.status).toBe('Active');\r\n        expect(active.startedAt).toBeDefined();\r\n        expect(canStartSession(s2, artifactId)).toBe(false);\r\n    });\r\n\r\n    it('should throw if starting a second active session for the same artifact', () => {\r\n        const { sessions: s1, session: d1 } = createSession([], artifactId);\r\n        const { sessions: s2 } = startSession(s1, d1.id);\r\n\r\n        const { sessions: s3, session: d2 } = createSession(s2, artifactId);\r\n\r\n        expect(() => startSession(s3, d2.id)).toThrow('Active session already exists for artifact');\r\n    });\r\n\r\n    it('should allow closing a session', () => {\r\n        const { sessions: s1, session: d1 } = createSession([], artifactId);\r\n        const { sessions: s2 } = startSession(s1, d1.id);\r\n        const s3 = closeSession(s2, d1.id);\r\n\r\n        expect(s3[0].status).toBe('Closed');\r\n        expect(s3[0].closedAt).toBeDefined();\r\n        expect(canStartSession(s3, artifactId)).toBe(true);\r\n    });\r\n\r\n    it('should correctly mark sessions as abandoned based on inactivity', () => {\r\n        const initialTime = 1000;\r\n        vi.setSystemTime(initialTime);\r\n\r\n        const { sessions: s1, session: d1 } = createSession([], artifactId);\r\n        const { sessions: s2 } = startSession(s1, d1.id);\r\n\r\n        // Threshold is e.g. 30 mins (1800000 ms)\r\n        const threshold = 1800000;\r\n\r\n        // Jump forward 31 mins\r\n        vi.setSystemTime(initialTime + threshold + 60000);\r\n\r\n        const abandoned = applyAbandonment(s2, threshold);\r\n        expect(abandoned[0].status).toBe('Abandoned');\r\n        expect(abandoned[0].abandonmentReason).toContain('Inactive');\r\n    });\r\n\r\n    it('should not abandon active sessions if they were recently active', () => {\r\n        const initialTime = 1000;\r\n        vi.setSystemTime(initialTime);\r\n\r\n        const { sessions: s1, session: d1 } = createSession([], artifactId);\r\n        const { sessions: s2 } = startSession(s1, d1.id);\r\n\r\n        const threshold = 1800000;\r\n\r\n        // Jump forward 15 mins\r\n        vi.setSystemTime(initialTime + threshold / 2);\r\n\r\n        const checked = applyAbandonment(s2, threshold);\r\n        expect(checked[0].status).toBe('Active');\r\n    });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\core\\sessions\\sessionStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\core\\sessions\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\core\\supabase\\client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\lib\\e2e.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\lib\\peerStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\lib\\utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\pages\\Artifacts.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\pages\\AuthCallbackPage.test.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":142,"column":83,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":142,"endColumn":86,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5246,5249],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5246,5249],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":164,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":164,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6007,6010],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6007,6010],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/** @vitest-environment jsdom */\r\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\r\nimport { render, screen, waitFor } from '@testing-library/react';\r\nimport AuthCallbackPage from './AuthCallbackPage';\r\nimport { supabase } from '../core/supabase/client';\r\nimport { MemoryRouter, useNavigate } from 'react-router-dom';\r\nimport type { Session, AuthTokenResponse } from '@supabase/supabase-js';\r\n\r\n// Mock useNavigate\r\nvi.mock('react-router-dom', async () => {\r\n    const actual = await vi.importActual('react-router-dom');\r\n    return {\r\n        ...actual,\r\n        useNavigate: vi.fn(),\r\n    };\r\n});\r\n\r\n// Mock Supabase\r\nvi.mock('../core/supabase/client', () => ({\r\n    supabase: {\r\n        auth: {\r\n            exchangeCodeForSession: vi.fn(),\r\n            setSession: vi.fn(),\r\n            getSession: vi.fn(),\r\n        }\r\n    }\r\n}));\r\n\r\ndescribe('AuthCallbackPage', () => {\r\n    const mockNavigate = vi.fn();\r\n\r\n    beforeEach(() => {\r\n        vi.clearAllMocks();\r\n        vi.mocked(useNavigate).mockReturnValue(mockNavigate);\r\n    });\r\n\r\n    it('should exchange code for session and redirect on success', async () => {\r\n        const mockLocation = new URL('http://localhost/auth/callback?code=test-code');\r\n        vi.stubGlobal('location', mockLocation);\r\n\r\n        const mockSession = { user: { email: 'test@example.com' } } as Session;\r\n        vi.mocked(supabase.auth.exchangeCodeForSession).mockResolvedValue({\r\n            data: { session: mockSession, user: mockSession.user },\r\n            error: null\r\n        } as AuthTokenResponse);\r\n\r\n        render(\r\n            <MemoryRouter>\r\n                <AuthCallbackPage />\r\n            </MemoryRouter>\r\n        );\r\n\r\n        expect(screen.getByText(/Authenticating/i)).toBeDefined();\r\n\r\n        await waitFor(() => {\r\n            expect(supabase.auth.exchangeCodeForSession).toHaveBeenCalledWith('test-code');\r\n        });\r\n\r\n        await waitFor(() => {\r\n            expect(screen.getByText(/Identity Verified/i)).toBeDefined();\r\n        }, { timeout: 2000 });\r\n\r\n        // Wait for the setTimeout redirect\r\n        await waitFor(() => {\r\n            expect(mockNavigate).toHaveBeenCalledWith('/', { replace: true });\r\n        }, { timeout: 3000 });\r\n    });\r\n\r\n    it('should handle redirectTo parameter on success', async () => {\r\n        const mockLocation = new URL('http://localhost/auth/callback?code=test-code&redirectTo=/board');\r\n        vi.stubGlobal('location', mockLocation);\r\n\r\n        const mockSession = { user: { email: 'test@example.com' } } as Session;\r\n        vi.mocked(supabase.auth.exchangeCodeForSession).mockResolvedValue({\r\n            data: { session: mockSession, user: mockSession.user },\r\n            error: null\r\n        } as AuthTokenResponse);\r\n\r\n        render(\r\n            <MemoryRouter>\r\n                <AuthCallbackPage />\r\n            </MemoryRouter>\r\n        );\r\n\r\n        await waitFor(() => {\r\n            expect(mockNavigate).toHaveBeenCalledWith('/board', { replace: true });\r\n        }, { timeout: 3000 });\r\n    });\r\n\r\n    it('should handle implicit flow tokens with setSession', async () => {\r\n        const mockLocation = new URL('http://localhost/auth/callback#access_token=abc&refresh_token=123');\r\n        vi.stubGlobal('location', mockLocation);\r\n\r\n        const mockSession = { user: { email: 'test@example.com' } } as Session;\r\n        vi.mocked(supabase.auth.setSession).mockResolvedValue({\r\n            data: { session: mockSession, user: mockSession.user },\r\n            error: null\r\n        } as AuthTokenResponse);\r\n\r\n        render(\r\n            <MemoryRouter>\r\n                <AuthCallbackPage />\r\n            </MemoryRouter>\r\n        );\r\n\r\n        await waitFor(() => {\r\n            expect(supabase.auth.setSession).toHaveBeenCalledWith({\r\n                access_token: 'abc',\r\n                refresh_token: '123'\r\n            });\r\n        });\r\n\r\n        await waitFor(() => {\r\n            expect(screen.getByText(/Identity Verified/i)).toBeDefined();\r\n        });\r\n    });\r\n\r\n    it('should handle hash-based errors (e.g. otp_expired)', async () => {\r\n        const mockLocation = new URL('http://localhost/auth/callback#error=access_denied&error_code=otp_expired&error_description=Email+link+is+invalid+or+has+expired');\r\n        vi.stubGlobal('location', mockLocation);\r\n\r\n        render(\r\n            <MemoryRouter>\r\n                <AuthCallbackPage />\r\n            </MemoryRouter>\r\n        );\r\n\r\n        await waitFor(() => {\r\n            expect(screen.getByText(/Seal Failure/i)).toBeDefined();\r\n            expect(screen.getByText(/CODE: otp_expired/i)).toBeDefined();\r\n            expect(screen.getByText(/Email link is invalid or has expired/i)).toBeDefined();\r\n            expect(screen.getByText(/use the most recent email link/i)).toBeDefined();\r\n        });\r\n    });\r\n\r\n    it('should show error message if code exchange fails', async () => {\r\n        const mockLocation = new URL('http://localhost/auth/callback?code=bad-code');\r\n        vi.stubGlobal('location', mockLocation);\r\n\r\n        vi.mocked(supabase.auth.exchangeCodeForSession).mockResolvedValue({\r\n            data: { session: null, user: null },\r\n            error: { message: 'Invalid code', name: 'AuthError', status: 400 } as any\r\n        } as AuthTokenResponse);\r\n\r\n        render(\r\n            <MemoryRouter>\r\n                <AuthCallbackPage />\r\n            </MemoryRouter>\r\n        );\r\n\r\n        await waitFor(() => {\r\n            expect(screen.getByText(/Seal Failure/i)).toBeDefined();\r\n            expect(screen.getByText(/Invalid code/i)).toBeDefined();\r\n        });\r\n    });\r\n\r\n    it('should fall back to getSession if no code or tokens are present', async () => {\r\n        vi.stubGlobal('location', new URL('http://localhost/auth/callback'));\r\n\r\n        const mockSession = { user: { email: 'test@example.com' } } as Session;\r\n        vi.mocked(supabase.auth.getSession).mockResolvedValue({\r\n            data: { session: mockSession },\r\n            error: null\r\n        } as any);\r\n\r\n        render(\r\n            <MemoryRouter>\r\n                <AuthCallbackPage />\r\n            </MemoryRouter>\r\n        );\r\n\r\n        await waitFor(() => {\r\n            expect(supabase.auth.getSession).toHaveBeenCalled();\r\n        });\r\n\r\n        await waitFor(() => {\r\n            expect(screen.getByText(/Identity Verified/i)).toBeDefined();\r\n        });\r\n    });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\pages\\AuthCallbackPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\pages\\BoardPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\pages\\Chamber.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\pages\\Lenses.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\pages\\Peers.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\pages\\Sessions.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\pages\\Settings.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\src\\vite-env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\tests\\global.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\tests\\governance-integrity.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\tests\\governance.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\tests\\ids_stream.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\tests\\session-stabilization.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\tests\\smoke.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\vite.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"E:\\AEGIS-COLAB-APP\\vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]